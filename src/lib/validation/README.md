# Input Validation System\n\nThis directory contains a comprehensive input validation system built with Zod that provides runtime type safety and security for all service functions and UI components.\n\n## ğŸ¯ Goals\n\n- **Runtime Safety**: Validate all inputs before processing\n- **Security**: Prevent injection attacks and malformed data\n- **User Experience**: Provide clear, actionable error messages\n- **Developer Experience**: Type-safe validation with excellent TypeScript integration\n- **Consistency**: Standardized validation patterns across the application\n\n## ğŸ“ File Structure\n\n```\nsrc/lib/validation/\nâ”œâ”€â”€ schemas.ts          # Zod validation schemas\nâ”œâ”€â”€ validator.ts        # Core validation utilities\nâ”œâ”€â”€ middleware.ts       # API route validation middleware\nâ”œâ”€â”€ ui-helpers.ts       # UI-specific validation helpers\nâ”œâ”€â”€ __tests__/         # Comprehensive test suite\nâ””â”€â”€ README.md          # This documentation\n```\n\n## ğŸ”§ Core Components\n\n### 1. Schemas (`schemas.ts`)\n\nDefines Zod schemas for all data types in the application:\n\n```typescript\nimport { createTransactionSchema, createCustomerSchema } from '@/lib/validation/schemas';\n\n// Example usage\nconst transactionData = {\n  type: 'expense',\n  category: 'Office Supplies',\n  description: 'Monthly supplies',\n  amount: '150.50'\n};\n\nconst result = createTransactionSchema.parse(transactionData);\n```\n\n**Available Schemas:**\n- `createTransactionSchema` / `updateTransactionSchema`\n- `createCustomerSchema` / `updateCustomerSchema`\n- `createLeadSchema` / `updateLeadSchema`\n- `createRecurringPaymentSchema` / `updateRecurringPaymentSchema`\n- `createInventoryItemSchema` / `updateInventoryItemSchema`\n- `createMileageEntrySchema` / `updateMileageEntrySchema`\n- `createInteractionSchema` / `updateInteractionSchema`\n\n- `paginationSchema`\n- `searchSchema`\n- `exportFilterSchema`\n\n### 2. Validator (`validator.ts`)\n\nCore validation functions that return consistent Result types:\n\n```typescript\nimport { validateInput, formatValidationErrors } from '@/lib/validation/validator';\nimport { createTransactionSchema } from '@/lib/validation/schemas';\n\nconst result = validateInput(createTransactionSchema, inputData);\n\nif (result.success) {\n  // Use validated data\n  console.log(result.data);\n} else {\n  // Handle validation errors\n  const errorMessage = formatValidationErrors(result.error);\n  console.error(errorMessage);\n}\n```\n\n**Key Functions:**\n- `validateInput<T>()` - Main validation function\n- `validatePartialInput<T>()` - For partial updates\n- `validateArray<T>()` - For arrays of data\n- `validateQueryParams<T>()` - For URL parameters\n- `formatValidationErrors()` - User-friendly error formatting\n\n### 3. Middleware (`middleware.ts`)\n\nAPI route validation middleware for Next.js:\n\n```typescript\nimport { withBodyValidation } from '@/lib/validation/middleware';\nimport { createTransactionSchema } from '@/lib/validation/schemas';\n\nexport const POST = withBodyValidation(\n  createTransactionSchema,\n  async (request, validatedData) => {\n    // validatedData is fully typed and validated\n    const result = await createTransaction(validatedData);\n    return NextResponse.json(result);\n  }\n);\n```\n\n**Available Middleware:**\n- `withBodyValidation()` - Validates request body\n- `withQueryValidation()` - Validates query parameters\n- `withValidation()` - Validates both body and query\n- `withErrorHandling()` - Standardized error handling\n- `withRateLimit()` - Rate limiting protection\n\n### 4. UI Helpers (`ui-helpers.ts`)\n\nReact-specific validation utilities:\n\n```typescript\nimport { createValidationState, formatErrorsForDisplay } from '@/lib/validation/ui-helpers';\n\nfunction MyComponent() {\n  const validationState = createValidationState();\n  \n  const handleSubmit = async (data) => {\n    const result = await validateAndSubmit(data);\n    \n    if (!result.success) {\n      validationState.setErrorsFromResult(result);\n    }\n  };\n  \n  return (\n    <input \n      className={validationState.getFieldClassName('email')}\n    />\n    {validationState.hasFieldError('email') && (\n      <span>{validationState.getFieldError('email')}</span>\n    )}\n  );\n}\n```\n\n## ğŸš€ Usage Examples\n\n### Service Function Validation\n\n```typescript\n// Before: No validation\nexport async function createTransaction(input: any): Promise<boolean> {\n  // Direct database call with unvalidated input\n}\n\n// After: With validation\nexport async function createTransaction(input: unknown): Promise<Result<boolean, string>> {\n  // Validate input\n  const validationResult = validateInput(createTransactionSchema, input);\n  if (!validationResult.success) {\n    return createError(formatValidationErrors(validationResult.error));\n  }\n\n  const validatedInput = validationResult.data;\n  // Proceed with validated data\n}\n```\n\n### React Component Validation\n\n```typescript\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { createTransactionSchema } from '@/lib/validation/schemas';\n\nfunction TransactionForm() {\n  const form = useForm({\n    resolver: zodResolver(createTransactionSchema),\n    mode: 'onBlur'\n  });\n\n  const onSubmit = async (data) => {\n    // data is automatically validated by react-hook-form + zod\n    const result = await createTransaction(data);\n    \n    if (!result.success) {\n      // Handle service-level validation errors\n      setError(result.error);\n    }\n  };\n\n  return (\n    <form onSubmit={form.handleSubmit(onSubmit)}>\n      {/* Form fields with automatic validation */}\n    </form>\n  );\n}\n```\n\n### API Route Validation\n\n```typescript\n// pages/api/transactions.ts\nimport { withValidatedHandler } from '@/lib/validation/middleware';\nimport { createTransactionSchema } from '@/lib/validation/schemas';\n\nexport const POST = withValidatedHandler(\n  createTransactionSchema,\n  async (request, validatedData) => {\n    const result = await createTransaction(validatedData);\n    \n    if (result.success) {\n      return createSuccessResponse(result.data);\n    } else {\n      return createErrorResponse(result.error, 400);\n    }\n  }\n);\n```\n\n## ğŸ›¡ï¸ Security Features\n\n### Input Sanitization\n- **String Length Limits**: Prevents buffer overflow attacks\n- **Type Validation**: Ensures data types match expectations\n- **Format Validation**: Email, phone, UUID, URL format checking\n- **Range Validation**: Numeric bounds checking\n\n### Attack Prevention\n- **SQL Injection**: Input validation prevents malicious SQL\n- **XSS Protection**: Data sanitization before display\n- **NoSQL Injection**: Schema validation prevents object injection\n- **File Upload**: MIME type and size validation\n\n### Rate Limiting\n```typescript\nimport { withRateLimit } from '@/lib/validation/middleware';\n\nexport const POST = withRateLimit(100, 60000)( // 100 requests per minute\n  withValidatedHandler(schema, handler)\n);\n```\n\n## ğŸ¨ Error Handling Patterns\n\n### 1. Service Layer Errors\n```typescript\n// Return Result type with validation errors\nif (!validationResult.success) {\n  return createError(formatValidationErrors(validationResult.error));\n}\n```\n\n### 2. API Route Errors\n```typescript\n// Standardized error response\nreturn createValidationErrorResponse(validationErrors);\n```\n\n### 3. UI Component Errors\n```typescript\n// Display user-friendly messages\nconst errorMessage = getUserFriendlyErrorMessage(validationError);\n```\n\n## ğŸ“Š Common Validation Patterns\n\n### Required Fields\n```typescript\nconst schema = z.object({\n  name: z.string().min(1, 'Name is required'),\n  email: z.string().email('Invalid email format'),\n});\n```\n\n### Optional Fields with Defaults\n```typescript\nconst schema = z.object({\n  status: z.enum(['active', 'inactive']).default('active'),\n  priority: z.enum(['low', 'medium', 'high']).optional(),\n});\n```\n\n### Conditional Validation\n```typescript\nconst schema = z.object({\n  type: z.enum(['recurring', 'one-time']),\n  frequency: z.enum(['daily', 'weekly', 'monthly']).optional(),\n}).refine(data => {\n  if (data.type === 'recurring' && !data.frequency) {\n    return false;\n  }\n  return true;\n}, {\n  message: 'Frequency is required for recurring transactions',\n  path: ['frequency']\n});\n```\n\n### Custom Validation\n```typescript\nconst phoneSchema = z.string().regex(\n  /^[\\+]?[1-9][\\d]{0,15}$/,\n  'Invalid phone number format'\n);\n\nconst currencySchema = z.string().regex(\n  /^\\d+(\\.\\d{1,2})?$/,\n  'Invalid currency format'\n);\n```\n\n## ğŸ§ª Testing\n\nRun the validation tests:\n```bash\nnpm test -- src/lib/validation/__tests__/validation.test.ts\n```\n\nThe test suite covers:\n- âœ… Valid input scenarios\n- âŒ Invalid input scenarios  \n- ğŸ”’ Security edge cases (XSS, SQL injection)\n- ğŸŒ Unicode and international input\n- ğŸ“Š Boundary conditions\n- ğŸ”„ Partial update scenarios\n\n## ğŸš¨ Migration Guide\n\n### Updating Existing Service Functions\n\n1. **Import validation utilities:**\n```typescript\nimport { validateInput, formatValidationErrors } from '@/lib/validation/validator';\nimport { createTransactionSchema } from '@/lib/validation/schemas';\n```\n\n2. **Change function signature:**\n```typescript\n// Before\nexport async function createTransaction(input: TransactionInput): Promise<boolean>\n\n// After  \nexport async function createTransaction(input: unknown): Promise<Result<boolean, string>>\n```\n\n3. **Add validation logic:**\n```typescript\nconst validationResult = validateInput(createTransactionSchema, input);\nif (!validationResult.success) {\n  return createError(formatValidationErrors(validationResult.error));\n}\n\nconst validatedInput = validationResult.data;\n```\n\n4. **Update error handling:**\n```typescript\n// Before\nif (error) {\n  return false;\n}\n\n// After\nif (error) {\n  return createError(error.message);\n}\n```\n\n### Updating React Components\n\n1. **Add Zod resolver to forms:**\n```typescript\nconst form = useForm({\n  resolver: zodResolver(validationSchema),\n  mode: 'onBlur'\n});\n```\n\n2. **Handle service-level errors:**\n```typescript\nconst onSubmit = async (data) => {\n  const result = await serviceFunction(data);\n  \n  if (!result.success) {\n    setSubmitError(result.error);\n  }\n};\n```\n\n3. **Display validation errors:**\n```typescript\n{submitError && (\n  <Alert variant=\"destructive\">\n    <AlertDescription>{submitError}</AlertDescription>\n  </Alert>\n)}\n```\n\n## ğŸ“š Best Practices\n\n1. **Always validate at service boundaries**\n2. **Use specific error messages**\n3. **Validate early, fail fast**\n4. **Keep schemas close to their usage**\n5. **Test edge cases thoroughly**\n6. **Use TypeScript inference from schemas**\n7. **Handle async validation properly**\n8. **Provide loading states during validation**\n9. **Sanitize data before display**\n10. **Log validation failures for monitoring**\n\n## ğŸ”§ Configuration\n\nCustomize validation behavior in your environment:\n\n```typescript\n// .env.local\nVALIDATION_STRICT_MODE=true\nVALIDATION_LOG_ERRORS=true\nRATE_LIMIT_ENABLED=true\nRATE_LIMIT_MAX_REQUESTS=100\nRATE_LIMIT_WINDOW_MS=60000\n```\n\n## ğŸ¤ Contributing\n\nWhen adding new validation schemas:\n\n1. Add schema to `schemas.ts`\n2. Export TypeScript types\n3. Add comprehensive tests\n4. Update this documentation\n5. Update affected service functions\n6. Update related UI components\n\n---\n\n**Remember**: Validation is your first line of defense against bad data and security vulnerabilities. Always validate inputs, provide clear error messages, and test edge cases thoroughly."